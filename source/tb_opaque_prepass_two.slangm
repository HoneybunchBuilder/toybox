#include "tb_gltf.slangh"
#include "tb_intrin.slangh"

[[vk::binding(0, 0)]]
ConstantBuffer<TbViewData> camera_data;
GLTF_DRAW_SET(1);
TB_MESHLET_SET(2);
TB_MESHLET_TRI_SET(3);
TB_MESHLET_VERT_SET(4);
TB_OBJECT_SET(5);
TB_IDX_SET(6);
TB_POS_SET(7);
TB_NORM_SET(8);

// TODO: Can we drive these from specialization constants?
#define NUM_THREADS_X TB_MESHLET_THREADS
#define NUM_THREADS_Y 1
#define NUM_THREADS_Z 1

struct VertexOut {
  float4 clip_pos : SV_POSITION;
  float3 normal : NORMAL0;
};

[shader("mesh")]
[outputtopology("triangle")]
[numthreads(NUM_THREADS_X, NUM_THREADS_Y, NUM_THREADS_Z)]
void mesh(uint32_t gtid: SV_GroupThreadID, uint32_t gid: SV_GroupID,
          out vertices VertexOut verts[TB_MESHLET_MAX_VERTICES],
          out indices uint3 triangles[TB_MESHLET_MAX_TRIANGLES]) {
  uint32_t draw_idx = tb_get_draw_index();
  TbGLTFDrawData draw = draw_data[draw_idx];

  uint32_t obj_idx = draw.obj_idx;
  uint32_t mesh_idx = draw.mesh_idx;
  uint32_t meshlet_idx = draw.meshlet_offset + gid;

  TbMeshlet meshlet = tb_get_meshlet(meshlets[mesh_idx], meshlet_idx);
  TbCommonObjectData obj_data = tb_get_obj_data(obj_idx, object_data);

  // Set number of outputs
  SetMeshOutputCounts(meshlet.vert_count, meshlet.prim_count);

  if (gtid < meshlet.vert_count) {
    uint32_t idx = tb_get_meshlet_vertex(meshlet_verts[mesh_idx], meshlet, gtid);

    int3 local_pos =
        tb_vert_get_local_pos(draw.perm, idx, mesh_idx, pos_buffers);
    float3 world_pos = mul(obj_data.m, float4(local_pos, 1)).xyz;
    float4 clip_pos = mul(camera_data.vp, float4(world_pos, 1.0));

    float3 normal = tb_vert_get_normal(draw.perm, idx, mesh_idx, norm_buffers);
    float3x3 orientation = (float3x3)obj_data.m;

    VertexOut vert = {};
    vert.clip_pos = clip_pos;
    vert.normal = mul(orientation, normal); // convert to world-space
    verts[gtid] = vert;
  }

  if (gtid < meshlet.prim_count) {
    triangles[gtid] =
        tb_get_meshlet_primitive(meshlet_prims[mesh_idx], meshlet, gtid);
  }
}

[shader("fragment")]
float4 frag(VertexOut vert) : SV_TARGET {
  float3 N = normalize(vert.normal) * 0.5 + 0.5; // Convert to UNORM
  return float4(N, 1);
}
